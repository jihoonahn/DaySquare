# This file contains the fastlane.tools configuration
# https://docs.fastlane.tools

default_platform(:ios)

# 환경 변수 로드
def load_env_file
  env_file = File.join(__dir__, ".env.default")
  return unless File.exist?(env_file)
  File.readlines(env_file).each do |line|
    next if line.strip.empty? || line.start_with?("#")
    key, value = line.strip.split("=", 2)
    next unless key && value
    ENV[key] = value.gsub(/^["']|["']$/, "")
  end
end
load_env_file

require "net/http"
require "json"
require "uri"
require "openssl"

# 경로·상수
PROJECT_ROOT = File.expand_path("..", __dir__)
APP_PROJECT_PATH = File.join(PROJECT_ROOT, "Projects", "App", "DaySquare.xcodeproj")
APP_IDENTIFIER = ENV["APP_IDENTIFIER"] || "com.jihoon.DaySquare"
WIDGET_IDENTIFIER = "#{APP_IDENTIFIER}.Widget"
WORKSPACE_NAME = "DaySquare.xcworkspace"
WORKSPACE_PATH = File.join(PROJECT_ROOT, WORKSPACE_NAME)
SCHEME_STAGE = "DaySquare-stage"
SCHEME_PROD = "DaySquare-prod"
EXPORT_OPTIONS_PLIST = "fastlane/ExportOptions.plist"
TEAM_ID = ENV["TEAM_ID"] || "PG5KXQ6FWQ"
# CI에서 setup_ci와 match가 같은 키체인을 쓰기 위한 이름
MATCH_KEYCHAIN_NAME = "fastlane_tmp_keychain"

def get_api_key
  return nil unless ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] && ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] && ENV["APP_STORE_CONNECT_API_KEY_KEY"]
  app_store_connect_api_key(
    key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
    issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
    key_content: ENV["APP_STORE_CONNECT_API_KEY_KEY"],
    in_house: false
  )
end

def read_changelog
  path = File.join(PROJECT_ROOT, "fastlane", "CHANGELOG.txt")
  return nil unless File.exist?(path)
  content = File.read(path).strip
  content.empty? ? nil : content
end

def get_version_info
  plist_path = File.join(PROJECT_ROOT, "Projects", "App", "iOS", "Support", "Info.plist")
  version = "1.0"
  build_number = "1"
  if File.exist?(plist_path)
    plist = File.read(plist_path)
    if m = plist.match(/<key>CFBundleShortVersionString<\/key>\s*<string>([^<]+)<\/string>/)
      version = m[1]
    end
    if m = plist.match(/<key>CFBundleVersion<\/key>\s*<string>([^<]+)<\/string>/)
      build_value = m[1]
      if build_value.start_with?("$") && File.exist?(APP_PROJECT_PATH)
        pbx = File.read(File.join(APP_PROJECT_PATH, "project.pbxproj"))
        build_number = (pbx =~ /CURRENT_PROJECT_VERSION\s*=\s*(\d+)/ ? $1 : "1")
      else
        build_number = build_value
      end
    end
  end
  { version: version, build_number: build_number }
end

def send_discord_notification(title:, description:, success: true, fields: [])
  webhook_url = ENV["DISCORD_WEBHOOK_URL"]
  return if webhook_url.to_s.strip.empty?
  color = success ? 30_669_93 : 15_158_332
  embed = {
    "title" => title.to_s[0, 256],
    "description" => description.to_s[0, 4096],
    "color" => color,
    "fields" => fields.map { |f| { "name" => f[:name].to_s[0, 256], "value" => f[:value].to_s[0, 1024], "inline" => f[:inline] != false } }
  }
  payload = { "embeds" => [embed] }
  payload["thread_name"] = ENV["DISCORD_THREAD_NAME"].to_s.strip if ENV["DISCORD_THREAD_NAME"].to_s.strip != ""
  uri = URI(ENV["DISCORD_WEBHOOK_URL"].strip)
  uri.query = URI.encode_www_form("thread_id" => ENV["DISCORD_THREAD_ID"].strip) if ENV["DISCORD_THREAD_ID"].to_s.strip != ""
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = (uri.scheme == "https")
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE if %w[1 true].include?(ENV["DISCORD_SKIP_SSL_VERIFY"].to_s)
  req = Net::HTTP::Post.new(uri.request_uri)
  req["Content-Type"] = "application/json"
  req.body = JSON.generate(payload)
  res = http.request(req)
  UI.success("Discord 알림 전송 완료") if res.is_a?(Net::HTTPSuccess)
rescue StandardError => e
  UI.important("Discord 알림 실패: #{e.message}")
end

platform :ios do
  # MARK: - 코드 서명

  desc "인증서·프로비저닝 프로파일 동기화 (읽기 전용)"
  lane :match_sync do
    match(
      type: "appstore",
      app_identifier: [APP_IDENTIFIER, WIDGET_IDENTIFIER],
      readonly: true,
      keychain_password: ENV["MATCH_KEYCHAIN_PASSWORD"] || ENV["MATCH_PASSWORD"],
      keychain_name: ENV["CI"] ? MATCH_KEYCHAIN_NAME : nil
    )
  end

  desc "새 인증서·프로비저닝 프로파일 생성"
  lane :match_new do
    match(type: "appstore", app_identifier: [APP_IDENTIFIER, WIDGET_IDENTIFIER])
  end

  # MARK: - 프로젝트

  desc "Tuist 프로젝트 생성"
  lane :generate do
    Dir.chdir(PROJECT_ROOT) do
      sh("tuist install")
      sh("tuist generate")
    end
  end

  # MARK: - 빌드·테스트

  desc "프로덕션 IPA 빌드"
  lane :build_prod do
    if ENV["CI"]
      setup_ci(force: true, keychain_name: MATCH_KEYCHAIN_NAME)
    end
    generate
    match_sync
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_PROD,
      configuration: "PROD",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID} -jobs 1",
      export_options: {
        method: "app-store",
        provisioningProfiles: { APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}", WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}" },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-prod.ipa",
      clean: true
    )
  end

  desc "테스트 실행"
  lane :test do
    generate
    run_tests(workspace: WORKSPACE_PATH, scheme: "DaySquare-dev", configuration: "DEV", clean: true)
  end

  # MARK: - 버전

  desc "빌드 번호만 1 증가"
  lane :bump_build_number do
    generate
    increment_build_number(xcodeproj: APP_PROJECT_PATH) if File.exist?(APP_PROJECT_PATH)
  end

  # MARK: - Archive (내부용 + 수동 빌드)

  desc "프로덕션 Archive 생성"
  lane :archive_prod do
    if ENV["CI"]
      setup_ci(force: true, keychain_name: MATCH_KEYCHAIN_NAME)
    end
    generate
    match_sync
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_PROD,
      configuration: "PROD",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID} -jobs 1",
      export_options: {
        method: "app-store",
        provisioningProfiles: { APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}", WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}" },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-prod",
      clean: true,
      skip_package_ipa: false
    )
  end

  desc "스테이징 Archive 생성"
  lane :archive_stage do
    if ENV["CI"]
      setup_ci(force: true, keychain_name: MATCH_KEYCHAIN_NAME)
    end
    generate
    match_sync
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_STAGE,
      configuration: "STAGE",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: { APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}", WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}" },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-stage",
      clean: true,
      skip_package_ipa: false
    )
  end

  # MARK: - TestFlight

  desc "스테이징 TestFlight 배포"
  lane :beta_stage do |options|
    changelog = options[:changelog] || read_changelog
    version_info = get_version_info
    archive_stage
    upload_to_testflight(api_key: get_api_key, skip_waiting_for_build_processing: false, distribute_external: false, notify_external_testers: false, changelog: changelog)
    send_discord_notification(
      title: "TestFlight 배포 성공 (Staging)",
      description: "DaySquare가 TestFlight에 업로드되었습니다.",
      success: true,
      fields: [
        { name: "Version", value: version_info[:version], inline: true },
        { name: "Build", value: version_info[:build_number], inline: true }
      ]
    )
  rescue StandardError => e
    send_discord_notification(title: "TestFlight 배포 실패 (Staging)", description: e.message, success: false)
    raise
  end

  desc "프로덕션 TestFlight 배포"
  lane :beta_prod do |options|
    changelog = options[:changelog] || read_changelog
    version_info = get_version_info
    archive_prod
    upload_to_testflight(api_key: get_api_key, skip_waiting_for_build_processing: false, distribute_external: false, notify_external_testers: false, changelog: changelog)
    send_discord_notification(
      title: "TestFlight 배포 성공 (Production)",
      description: "DaySquare가 TestFlight에 업로드되었습니다.",
      success: true,
      fields: [
        { name: "Version", value: version_info[:version], inline: true },
        { name: "Build", value: version_info[:build_number], inline: true }
      ]
    )
  rescue StandardError => e
    send_discord_notification(title: "TestFlight 배포 실패 (Production)", description: e.message, success: false)
    raise
  end

  # MARK: - App Store

  desc "App Store 업로드 + 심사 제출"
  lane :release do
    generate
    version_info = get_version_info
    UI.message("Version: #{version_info[:version]} / Build: #{version_info[:build_number]}")
    archive_prod

    upload_to_app_store(
      api_key: get_api_key,
      skip_metadata: true,
      skip_screenshots: true,
      force: true,
      submit_for_review: true,
      automatic_release: false,
      run_precheck_before_submit: false  # API Key로 IAP precheck 미지원
    )
  end

  desc "스크린샷만 업로드 (fastlane/screenshots/ JPEG/PNG)"
  lane :upload_screenshots_only do
    deliver(
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      force: true,
      run_precheck_before_submit: false
    )
  rescue RuntimeError => e
    UI.important("첫 버전에서는 'No data'로 실패할 수 있습니다. 스크린샷은 App Store Connect에서 수동 업로드하세요.") if e.message.include?("No data")
    raise unless e.message.include?("No data")
  end

  # MARK: - 배포 워크플로우

  desc "빌드 번호 증가 후 TestFlight 배포 (stage 또는 prod)"
  lane :deploy_new_feature do |options|
    env = options[:environment] || "stage"
    changelog = options[:changelog] || read_changelog
    bump_build_number
    version_info = get_version_info
    UI.message("Version: #{version_info[:version]} / Build: #{version_info[:build_number]}")
    env == "prod" ? beta_prod(changelog: changelog) : beta_stage(changelog: changelog)
  end

  desc "버전 문자열 변경 후 빌드 1로 초기화 + TestFlight 배포"
  lane :deploy_new_version do |options|
    new_version = options[:version]
    env = options[:environment] || "stage"
    changelog = options[:changelog] || read_changelog
    UI.user_error!("version 필요: fastlane deploy_new_version version:\"1.1\"") unless new_version
    generate
    increment_version_number(version_number: new_version, xcodeproj: APP_PROJECT_PATH)
    increment_build_number(build_number: "1", xcodeproj: APP_PROJECT_PATH)
    version_info = get_version_info
    UI.message("Version: #{version_info[:version]} / Build: #{version_info[:build_number]}")
    env == "prod" ? beta_prod(changelog: changelog) : beta_stage(changelog: changelog)
  end

  # MARK: - 유틸

  desc "빌드·DerivedData 정리"
  lane :clean do
    Dir.chdir(PROJECT_ROOT) { sh("tuist clean") }
    sh("rm -rf #{File.join(PROJECT_ROOT, 'build')} #{File.join(PROJECT_ROOT, 'DerivedData')}")
  end

  desc "버전·번들 ID 등 정보 출력"
  lane :info do
    generate unless File.exist?(WORKSPACE_PATH)
    v = get_version_info
    UI.message("App: #{APP_IDENTIFIER}")
    UI.message("Version: #{v[:version]} / Build: #{v[:build_number]}")
  end
end

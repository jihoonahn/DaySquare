# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
def load_env_file
  env_file = File.join(__dir__, ".env.default")
  if File.exist?(env_file)
    File.readlines(env_file).each do |line|
      next if line.strip.empty? || line.start_with?("#")
      key, value = line.strip.split("=", 2)
      if key && value
        # ë”°ì˜´í‘œ ì œê±° (ì–‘ìª½ ë”°ì˜´í‘œ ëª¨ë‘ ì œê±°)
        value = value.gsub(/^["']|["']$/, "")
        ENV[key] = value
      end
    end
  end
end

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_env_file

require "net/http"
require "json"
require "uri"
require "openssl"

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ (fastlane ë””ë ‰í† ë¦¬ì˜ ë¶€ëª¨)
PROJECT_ROOT = File.expand_path("..", __dir__)

# Tuistê°€ ìƒì„±í•˜ëŠ” xcodeproj ê²½ë¡œ
APP_PROJECT_PATH = File.join(PROJECT_ROOT, "Projects", "App", "DaySquare.xcodeproj")

# ê³µí†µ ë³€ìˆ˜
APP_IDENTIFIER = ENV["APP_IDENTIFIER"] || "me.jihoon.DaySquare"
WIDGET_IDENTIFIER = "#{APP_IDENTIFIER}.Widget"
WORKSPACE_NAME = "DaySquare.xcworkspace"
WORKSPACE_PATH = File.join(PROJECT_ROOT, WORKSPACE_NAME)
SCHEME_DEV = "DaySquare-dev"
SCHEME_STAGE = "DaySquare-stage"
SCHEME_PROD = "DaySquare-prod"
EXPORT_OPTIONS_PLIST = "fastlane/ExportOptions.plist"
TEAM_ID = ENV["TEAM_ID"] || "PG5KXQ6FWQ"

platform :ios do
  # MARK: - Match (ì¸ì¦ì„œ ë° í”„ë¡œë¹„ì €ë‹ í”„ë¡œíŒŒì¼ ê´€ë¦¬)
  
  desc "Matchë¥¼ í†µí•´ ì¸ì¦ì„œ ë° í”„ë¡œë¹„ì €ë‹ í”„ë¡œíŒŒì¼ ë™ê¸°í™”"
  lane :match_sync do
    match(
      type: "appstore",
      app_identifier: [APP_IDENTIFIER, WIDGET_IDENTIFIER],
      readonly: true
    )
  end

  desc "Matchë¥¼ í†µí•´ ìƒˆë¡œìš´ ì¸ì¦ì„œ ë° í”„ë¡œë¹„ì €ë‹ í”„ë¡œíŒŒì¼ ìƒì„±"
  lane :match_new do
    match(
      type: "appstore",
      app_identifier: [APP_IDENTIFIER, WIDGET_IDENTIFIER]
    )
  end

  # MARK: - Tuist í”„ë¡œì íŠ¸ ìƒì„±

  desc "Tuist í”„ë¡œì íŠ¸ ìƒì„±"
  lane :generate do
    Dir.chdir(PROJECT_ROOT) do
      # ì˜ì¡´ì„± ì„¤ì¹˜ (í•„ìš”í•œ ê²½ìš°)
      sh("tuist install")
      # í”„ë¡œì íŠ¸ ìƒì„±
      sh("tuist generate")
    end
  end

  desc "Tuist ì˜ì¡´ì„± ì„¤ì¹˜"
  lane :install_dependencies do
    Dir.chdir(PROJECT_ROOT) do
      sh("tuist install")
    end
  end

  desc "Tuist í”„ë¡œì íŠ¸ ì •ë¦¬"
  lane :clean_tuist do
    Dir.chdir(PROJECT_ROOT) do
      sh("tuist clean")
    end
  end

  # MARK: - ë¹Œë“œ

  desc "ê°œë°œ í™˜ê²½ ë¹Œë“œ"
  lane :build_dev do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_DEV,
      configuration: "DEV",
      export_method: "app-store",  # App Store í”„ë¡œíŒŒì¼ ì‚¬ìš©
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-dev.ipa",
      clean: true
    )
  end

  desc "ìŠ¤í…Œì´ì§• í™˜ê²½ ë¹Œë“œ"
  lane :build_stage do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_STAGE,
      configuration: "STAGE",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-stage.ipa",
      clean: true
    )
  end

  desc "í”„ë¡œë•ì…˜ í™˜ê²½ ë¹Œë“œ"
  lane :build_prod do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_PROD,
      configuration: "PROD",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-prod.ipa",
      clean: true
    )
  end

  # MARK: - í…ŒìŠ¤íŠ¸

  desc "ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰"
  lane :test do
    generate
    
    run_tests(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_DEV,
      configuration: "DEV",
      clean: true,
      code_coverage: true
    )
  end

  desc "íŠ¹ì • ìŠ¤í‚´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"
  lane :test_scheme do |options|
    scheme = options[:scheme] || SCHEME_DEV
    generate
    
    run_tests(
      workspace: WORKSPACE_PATH,
      scheme: scheme,
      clean: true,
      code_coverage: true
    )
  end

  # MARK: - ë²„ì „ ê´€ë¦¬

  desc "ë²„ì „ ë²ˆí˜¸ ì¦ê°€ (build number)"
  lane :bump_build_number do
    generate
    if File.exist?(APP_PROJECT_PATH)
      increment_build_number(xcodeproj: APP_PROJECT_PATH)
    else
      UI.user_error!("í”„ë¡œì íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{APP_PROJECT_PATH}")
    end
  end

  desc "ë²„ì „ ë²ˆí˜¸ ì„¤ì •"
  lane :set_build_number do |options|
    build_number = options[:build_number]
    generate
    if File.exist?(APP_PROJECT_PATH)
      increment_build_number(
        build_number: build_number,
        xcodeproj: APP_PROJECT_PATH
      )
    else
      UI.user_error!("í”„ë¡œì íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{APP_PROJECT_PATH}")
    end
  end

  desc "ë²„ì „ ë¬¸ìì—´ ì¦ê°€ (version string)"
  lane :bump_version do |options|
    version_number = options[:version]
    generate
    if File.exist?(APP_PROJECT_PATH)
      increment_version_number(
        version_number: version_number,
        xcodeproj: APP_PROJECT_PATH
      )
    else
      UI.user_error!("í”„ë¡œì íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{APP_PROJECT_PATH}")
    end
  end

  # MARK: - Archive

  desc "ê°œë°œ í™˜ê²½ Archive ìƒì„±"
  lane :archive_dev do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_DEV,
      configuration: "DEV",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-dev",
      clean: true,
      skip_package_ipa: false
    )
  end

  desc "ìŠ¤í…Œì´ì§• í™˜ê²½ Archive ìƒì„±"
  lane :archive_stage do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_STAGE,
      configuration: "STAGE",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-stage",
      clean: true,
      skip_package_ipa: false
    )
  end

  desc "í”„ë¡œë•ì…˜ í™˜ê²½ Archive ìƒì„±"
  lane :archive_prod do
    generate
    match_sync
    
    build_app(
      workspace: WORKSPACE_PATH,
      scheme: SCHEME_PROD,
      configuration: "PROD",
      export_method: "app-store",
      xcargs: "DEVELOPMENT_TEAM=#{TEAM_ID} -jobs 1",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}",
          WIDGET_IDENTIFIER => "match AppStore #{WIDGET_IDENTIFIER}"
        },
        signingStyle: "manual",
        teamID: TEAM_ID
      },
      output_directory: File.join(PROJECT_ROOT, "build"),
      output_name: "DaySquare-prod",
      clean: true,
      skip_package_ipa: false
    )
  end

  # MARK: - ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ê´€ë¦¬

  # ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ íŒŒì¼ ì½ê¸°
  def read_changelog
    changelog_file = File.join(PROJECT_ROOT, "fastlane", "CHANGELOG.txt")
    if File.exist?(changelog_file)
      content = File.read(changelog_file).strip
      content.empty? ? nil : content
    else
      nil
    end
  end

  # Discord ì•Œë¦¼ ì „ì†¡ í—¬í¼ (Net::HTTP ì‚¬ìš©, í”ŒëŸ¬ê·¸ì¸ ì˜ì¡´ ì—†ìŒ, ì‹¤íŒ¨ ì‹œ lane ì‹¤íŒ¨ ì•ˆ í•¨)
  def send_discord_notification(title:, description:, success: true, fields: [])
    webhook_url = ENV["DISCORD_WEBHOOK_URL"]
    unless webhook_url && !webhook_url.to_s.strip.empty?
      UI.important("DISCORD_WEBHOOK_URL ë¯¸ì„¤ì • â†’ ì•Œë¦¼ ê±´ë„ˆëœ€")
      return
    end
    
    color = success ? 30_669_93 : 15_158_332  # green / red
    embed = {
      "title" => title.to_s[0, 256],
      "description" => description.to_s[0, 4096],
      "color" => color,
      "fields" => fields.map { |f|
        { "name" => f[:name].to_s[0, 256], "value" => f[:value].to_s[0, 1024], "inline" => f[:inline] != false }
      }
    }
    payload = { "embeds" => [embed] }
    payload["thread_name"] = ENV["DISCORD_THREAD_NAME"].to_s.strip if ENV["DISCORD_THREAD_NAME"] && !ENV["DISCORD_THREAD_NAME"].to_s.strip.empty?
    body = JSON.generate(payload)
    
    uri = URI(webhook_url.strip)
    if (tid = ENV["DISCORD_THREAD_ID"]) && !tid.to_s.strip.empty?
      uri.query = URI.encode_www_form("thread_id" => tid.strip)
    end
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = (uri.scheme == "https")
    if ENV["DISCORD_SKIP_SSL_VERIFY"] == "1" || ENV["DISCORD_SKIP_SSL_VERIFY"] == "true"
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end
    http.open_timeout = 10
    http.read_timeout = 10
    req = Net::HTTP::Post.new(uri.request_uri)
    req["Content-Type"] = "application/json"
    req.body = body
    res = http.request(req)
    
    if res.is_a?(Net::HTTPSuccess)
      UI.success("Discord ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
    else
      err_detail = res.body.to_s.strip
      err_detail = JSON.parse(err_detail)["message"] rescue err_detail
      UI.important("Discord ì•Œë¦¼ ì‹¤íŒ¨: #{res.code} #{res.message}")
      UI.important("ì‘ë‹µ: #{err_detail}") if err_detail && !err_detail.empty?
    end
  rescue StandardError => ex
    UI.important("Discord ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: #{ex.message}")
    UI.important(ex.backtrace.first(3).join("\n")) if ENV["FASTLANE_DISCORD_DEBUG"]
  end

  # ë²„ì „ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (Info.plistì—ì„œ ì§ì ‘ ì½ê¸°)
  def get_version_info
    info_plist_path = File.join(PROJECT_ROOT, "Projects", "App", "iOS", "Support", "Info.plist")
    version = "1.0"
    build_number = "1"
    
    if File.exist?(info_plist_path)
      plist_content = File.read(info_plist_path)
      
      # CFBundleShortVersionString ì½ê¸°
      if match = plist_content.match(/<key>CFBundleShortVersionString<\/key>\s*<string>([^<]+)<\/string>/)
        version = match[1]
      end
      
      # CFBundleVersion ì½ê¸° - ë³€ìˆ˜ì¸ ê²½ìš° í”„ë¡œì íŠ¸ì—ì„œ ì½ê¸°
      if match = plist_content.match(/<key>CFBundleVersion<\/key>\s*<string>([^<]+)<\/string>/)
        build_value = match[1]
        if build_value.start_with?("$")
          # agvtool ëŒ€ì‹  í”„ë¡œì íŠ¸ íŒŒì¼ì—ì„œ ì§ì ‘ ì½ê¸°
          if File.exist?(APP_PROJECT_PATH)
            begin
              project_content = File.read(File.join(APP_PROJECT_PATH, "project.pbxproj"))
              if ver_match = project_content.match(/CURRENT_PROJECT_VERSION\s*=\s*(\d+)/)
                build_number = ver_match[1]
              end
            rescue
              build_number = "1"
            end
          end
        else
          build_number = build_value
        end
      end
    end
    
    { version: version, build_number: build_number }
  end

  desc "ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ì‘ì„± (CHANGELOG.txt íŒŒì¼ ìƒì„±/ìˆ˜ì •)"
  lane :write_changelog do |options|
    changelog = options[:changelog]
    UI.user_error!("ë³€ê²½ì‚¬í•­ì„ ì…ë ¥í•´ì£¼ì„¸ìš”: fastlane write_changelog changelog:\"ë³€ê²½ì‚¬í•­ ë‚´ìš©\"") unless changelog
    
    changelog_file = File.join(PROJECT_ROOT, "fastlane", "CHANGELOG.txt")
    File.write(changelog_file, changelog)
    UI.success("âœ… ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: #{changelog_file}")
    UI.message("ğŸ“ ë‚´ìš©:")
    UI.message(changelog)
  end

  # MARK: - TestFlight ë°°í¬

  desc "ìŠ¤í…Œì´ì§• í™˜ê²½ TestFlight ë°°í¬"
  lane :beta_stage do |options|
    changelog = options[:changelog] || read_changelog
    version_info = get_version_info
    
    begin
      archive_stage
      upload_to_testflight(
        skip_waiting_for_build_processing: false,
        distribute_external: false,
        notify_external_testers: false,
        changelog: changelog
      )
      
      # Discord ì•Œë¦¼ (ì„±ê³µ)
      send_discord_notification(
        title: "âœ… TestFlight ë°°í¬ ì„±ê³µ (Staging)",
        description: "DaySquare ì•±ì´ TestFlightì— ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.",
        success: true,
        fields: [
          { name: "Version", value: version_info[:version], inline: true },
          { name: "Build", value: version_info[:build_number], inline: true },
          { name: "Environment", value: "Staging", inline: true }
        ]
      )
    rescue => ex
      # Discord ì•Œë¦¼ (ì‹¤íŒ¨)
      send_discord_notification(
        title: "âŒ TestFlight ë°°í¬ ì‹¤íŒ¨ (Staging)",
        description: "ë°°í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: #{ex.message}",
        success: false
      )
      raise
    end
  end

  desc "í”„ë¡œë•ì…˜ í™˜ê²½ TestFlight ë°°í¬"
  lane :beta_prod do |options|
    changelog = options[:changelog] || read_changelog
    version_info = get_version_info
    
    begin
      archive_prod
      upload_to_testflight(
        skip_waiting_for_build_processing: false,
        distribute_external: false,
        notify_external_testers: false,
        changelog: changelog
      )
      
      # Discord ì•Œë¦¼ (ì„±ê³µ)
      send_discord_notification(
        title: "âœ… TestFlight ë°°í¬ ì„±ê³µ (Production)",
        description: "DaySquare ì•±ì´ TestFlightì— ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.",
        success: true,
        fields: [
          { name: "Version", value: version_info[:version], inline: true },
          { name: "Build", value: version_info[:build_number], inline: true },
          { name: "Environment", value: "Production", inline: true }
        ]
      )
    rescue => ex
      # Discord ì•Œë¦¼ (ì‹¤íŒ¨)
      send_discord_notification(
        title: "âŒ TestFlight ë°°í¬ ì‹¤íŒ¨ (Production)",
        description: "ë°°í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: #{ex.message}",
        success: false
      )
      raise
    end
  end

  desc "TestFlight ë°°í¬ (ì™¸ë¶€ í…ŒìŠ¤í„°ì—ê²Œ ë°°í¬)"
  lane :beta_external do |options|
    scheme = options[:scheme] || SCHEME_STAGE
    changelog = options[:changelog] || read_changelog
    version_info = get_version_info
    
    begin
      if scheme == SCHEME_PROD
        archive_prod
      else
        archive_stage
      end
      
      upload_to_testflight(
        skip_waiting_for_build_processing: false,
        distribute_external: true,
        notify_external_testers: true,
        changelog: changelog
      )
      
      # Discord ì•Œë¦¼ (ì„±ê³µ)
      send_discord_notification(
        title: "âœ… TestFlight ì™¸ë¶€ ë°°í¬ ì„±ê³µ",
        description: "DaySquare ì•±ì´ ì™¸ë¶€ í…ŒìŠ¤í„°ì—ê²Œ ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤.",
        success: true,
        fields: [
          { name: "Version", value: version_info[:version], inline: true },
          { name: "Build", value: version_info[:build_number], inline: true },
          { name: "Scheme", value: scheme, inline: true }
        ]
      )
    rescue => ex
      # Discord ì•Œë¦¼ (ì‹¤íŒ¨)
      send_discord_notification(
        title: "âŒ TestFlight ì™¸ë¶€ ë°°í¬ ì‹¤íŒ¨",
        description: "ë°°í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: #{ex.message}",
        success: false
      )
      raise
    end
  end

  # MARK: - App Store ë°°í¬

  desc "App Storeì— ë°°í¬"
  lane :release do
    generate
    
    # í”„ë¡œì íŠ¸ íŒŒì¼ì—ì„œ ë²„ì „ í™•ì¸
    version_info = get_version_info
    UI.message("ğŸ“± ë°°í¬ ì •ë³´:")
    UI.message("   Version: #{version_info[:version]}")
    UI.message("   Build: #{version_info[:build_number]}")
    
    # Archive ìƒì„±
    archive_prod
    
    # App Storeì— ì—…ë¡œë“œ
    upload_to_app_store(
      skip_metadata: false,
      skip_screenshots: false,
      force: true,
      submit_for_review: false,
      automatic_release: false
    )
  end

  # MARK: - ì „ì²´ ë°°í¬ ì›Œí¬í”Œë¡œìš°

  desc "ìƒˆ ê¸°ëŠ¥ ë°°í¬ (ë¹Œë“œ ë²ˆí˜¸ ìë™ ì¦ê°€ + TestFlight ì—…ë¡œë“œ)"
  lane :deploy_new_feature do |options|
    environment = options[:environment] || "stage"
    changelog = options[:changelog] || read_changelog
    
    # ë¹Œë“œ ë²ˆí˜¸ ìë™ ì¦ê°€
    bump_build_number
    
    # í˜„ì¬ ë²„ì „ ì •ë³´ ì¶œë ¥
    version_info = get_version_info
    UI.message("ğŸ“± ë°°í¬ ì •ë³´:")
    UI.message("   Version: #{version_info[:version]}")
    UI.message("   Build: #{version_info[:build_number]}")
    
    # TestFlight ë°°í¬
    if environment == "prod"
      beta_prod(changelog: changelog)
    else
      beta_stage(changelog: changelog)
    end
  end

  desc "ìƒˆ ë²„ì „ ë°°í¬ (ë²„ì „ ë¬¸ìì—´ ë³€ê²½ + ë¹Œë“œ ë²ˆí˜¸ ì´ˆê¸°í™” + TestFlight ì—…ë¡œë“œ)"
  lane :deploy_new_version do |options|
    new_version = options[:version]
    environment = options[:environment] || "stage"
    changelog = options[:changelog] || read_changelog
    
    UI.user_error!("ìƒˆ ë²„ì „ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”: fastlane deploy_new_version version:\"1.1\"") unless new_version
    
    # ë²„ì „ ë¬¸ìì—´ ë³€ê²½
    bump_version(version: new_version)
    
    # ë¹Œë“œ ë²ˆí˜¸ë¥¼ 1ë¡œ ì´ˆê¸°í™”
    set_build_number(build_number: "1")
    
    # í˜„ì¬ ë²„ì „ ì •ë³´ ì¶œë ¥
    version_info = get_version_info
    UI.message("ğŸ“± ë°°í¬ ì •ë³´:")
    UI.message("   Version: #{version_info[:version]}")
    UI.message("   Build: #{version_info[:build_number]}")
    
    # TestFlight ë°°í¬
    if environment == "prod"
      beta_prod(changelog: changelog)
    else
      beta_stage(changelog: changelog)
    end
  end

  # MARK: - ìœ í‹¸ë¦¬í‹°

  desc "í”„ë¡œì íŠ¸ ì •ë¦¬"
  lane :clean do
    clean_tuist
    Dir.chdir(PROJECT_ROOT) do
      sh("rm -rf build")
      sh("rm -rf DerivedData")
    end
    sh("rm -rf ~/Library/Developer/Xcode/DerivedData")
  end

  desc "Discord ì›¹í›… í…ŒìŠ¤íŠ¸ (ì•Œë¦¼ì´ ì˜¤ëŠ”ì§€ í™•ì¸)"
  lane :discord_test do
    webhook_url = ENV["DISCORD_WEBHOOK_URL"]
    unless webhook_url && !webhook_url.to_s.strip.empty?
      UI.user_error!("DISCORD_WEBHOOK_URLì„ .env.defaultì— ì„¤ì •í•œ ë’¤ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
    end

    UI.message("Discord ì›¹í›… í…ŒìŠ¤íŠ¸ ì „ì†¡ ì¤‘...")
    send_discord_notification(
      title: "DaySquare Fastlane í…ŒìŠ¤íŠ¸",
      description: "Discord ì•Œë¦¼ì´ ì •ìƒ ë™ì‘í•©ë‹ˆë‹¤.",
      success: true,
      fields: [
        { name: "ì•±", value: "DaySquare", inline: true },
        { name: "í…ŒìŠ¤íŠ¸", value: "ì„±ê³µ", inline: true }
      ]
    )
  end

  desc "ì½”ë“œ ì‚¬ì´ë‹ ì •ë³´ í™•ì¸"
  lane :check_signing do
    match_sync
    get_certificates
    get_provisioning_profile
  end

  desc "í”„ë¡œì íŠ¸ ì •ë³´ ì¶œë ¥"
  lane :info do
    workspace_path = File.join(PROJECT_ROOT, WORKSPACE_NAME)
    
    # í”„ë¡œì íŠ¸ê°€ ìƒì„±ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ìƒì„±
    unless File.exist?(workspace_path)
      generate
    end
    
    version_info = get_version_info
    
    UI.message("ğŸ“± DaySquare í”„ë¡œì íŠ¸ ì •ë³´")
    UI.message("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    UI.message("   App Identifier: #{APP_IDENTIFIER}")
    UI.message("   Widget Identifier: #{WIDGET_IDENTIFIER}")
    UI.message("   Version: #{version_info[:version]}")
    UI.message("   Build Number: #{version_info[:build_number]}")
    UI.message("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
  end

  # MARK: - CI/CD

  desc "CI í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì „ì²´ íŒŒì´í”„ë¼ì¸"
  lane :ci do
    # ì˜ì¡´ì„± ì„¤ì¹˜
    install_dependencies
    
    # í”„ë¡œì íŠ¸ ìƒì„±
    generate
    
    # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    test
    
    # ë¹Œë“œ í™•ì¸
    build_dev
  end

  desc "CD í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ëŠ” ë°°í¬ íŒŒì´í”„ë¼ì¸"
  lane :cd do |options|
    environment = options[:environment] || "stage"
    
    case environment
    when "stage"
      beta_stage
    when "prod"
      beta_prod
    else
      UI.user_error!("Unknown environment: #{environment}. Use 'stage' or 'prod'")
    end
  end
end
